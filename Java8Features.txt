The Java8 Fetaures:
Content:
1.Lambda Expressions  ->  Not a replacement for annonymous Inner classes -> annonymous Inner classes which have implement only one abstract method can be replaced with lambda expression
2.Functional Interface
3.Using Default Methods in Interfaces
4.Using Static Methods in Interfaces
5.Java8 Defined Functional Interfaces -> Predicate, Function, Consumer, Supplier
6.Method Reference and Constructor reference by using double colon (::) operator
7.Stream API -> to perform operations on collections by writing more readable and maintainable code
8.Date and Time API using JODA API -> joda.org

Theory:
1.Lambda Expressions 
	a)To Enable Functional Programming in Java
	b)To write more readable, maintainable and concise code
	c)To use API's more easily and efficiently
	d)To Enable Parallel processing
-> Anonymous class will not have any name, return type and modifiers. An annonymous class can be writen simply by using lambda expression
->For example if we have a abstract class with one abstarct method as shown below:
abstract class Person{  
  abstract void eat();  
}  

->We can implement the above eat() method using the annonymous inner class as shown below:
class Test{  
 public static void main(String args[]){  
  Person p=new Person(){                             // -> This is called annonymous inner class
  void eat(){System.out.println("nice fruits");}  
  };  
  p.eat();  
 }  
}  

->The same eat() method we can implement using the lambda expression in a more readable and efficiently way
class TestAnonymousInner{  
 public static void main(String args[]){
	Person p = () -> {System.out.println("nice fruits");}   // -> This is a lambda expression of the above annonymous inner class
 } 
}

->Some examples of writing lambda expressions
->Ex:1
abstract class sum{  
  abstract void add(int a, int b);        
}  
class Test{  
 public static void main(String args[]){  
  Sum s=(a,b) -> System.out.println(a+b);  // -> here mentioning data type is not needed it is automatically guessed by compiler this is call TYPE INFERENCE
  s.add(3,4);
}
}  
->Ex:2
abstract class Student{  
  abstract String addNames(String fName, String lName);        
}  
class Test{  
 public static void main(String args[]){  
  Student s=(fName,lName) -> fName+lName;  // -> here mentioning return is not needed it is automatically guessed by compiler and curly braces are needed only of we are writing more than one statement
  s.add(3,4);    
}
}  
NOTE: From the above examples we can see that all the abstract classes have only one abstract method 
So we can conclude that lambda expressions can be writen to a abstarct class or interface which has only one abstract method.

2.Functional Interface
->Functional Interface is an interface which has only one abstract method and the Interface and it can have any number of default and static methods and it should be annotated with @FunctionalInterface.
-> @FunctionalInterface indicates that the interface is a functional interface and if the developers try to create more then one abstract methods then the compiler will show error
->To write a lambda expression to a interface that interface must and should be a Functional Interface 
Already predefined Functional Interfaces in Java before Java 8 are 
	a)Runnable contains only run() method
	b)Callable contains only call() method
	c)ActionListener  contains only actionPerformed() method
	d)Comparable contains only compareTo() method

AnonymousInnerClass vs Lambda Expression difference: Refer the image: AnonymousInnerClassVsLambdaExpression.png
	
3.Using Default Methods in Interfaces
Before Java8 we cannot declare a concreate method inside and interface
From Java8 we can declare a concreate method inside interface using default keyword
Example:
interface Sayable{  
    // Default method   
    default void say(){  
        System.out.println("Hello, this is default method");  
    }  
    // Abstract method  
    void sayMore(String msg);  
}  
public class DefaultMethods implements Sayable{  
    public void sayMore(String msg){        // implementing abstract method   
        System.out.println(msg);  
    }  
    public static void main(String[] args) {  
        DefaultMethods dm = new DefaultMethods();  
        dm.say();   // calling default method  
        dm.sayMore("Work is worship");  // calling abstract method  
  
    }  
}  
To call the defualt method one should implement the interface and then we can create a obj of implemented class to call default method
Default method can be used as it is by the implemented class or it can be overriden as per the requirment
->Default methods with multiple inheritence:
->For example if two interfaces have same default method names but the implementation is different.
IF a class implements the above two interfaces then the compiler will throws the ambiguity error that which method it should use
this can be solved by using the below example
interface A{
	default void m1(){
		S.O.P("A");
		}
}
interface B{
	default void m1(){
		S.O.P("B");
		}
}
class Test implements A,B{
	// this will throw the error that which m1 method it should use it can solved by overrding m1() or by using the super keyword
	public void m1(){
		A.super.m1() // this will call the interface A m1() method
	}
}
Difference between Interface with default method and abstract classes: Refer the image: InterfaceWithDefaultMethodsVsAbstractClass.png
NOTE: In interface by default all the variables are public static final.

4.Static Methods in Interface:
From java 8 we can create static conncreate methods in an interface which can be used for implementing common utility methods
Example:
public interface Student {

    static String getUtil(){
        return "Utils";
    }
}
public class Main {

    public static void main(String[] args) {
        System.out.println(Student.getUtil());  // the static methods comes with the Interface not with the object. It never stores the state. 
		                                       //And these static methods can only be called by using Interface name and not by the implemented classes
    }
}
NOTE: 
a.Staic methods defined in an interface will not be available in the implemented class by default
b.Method overrding is not possible for interface static methods
c.From java 8 as we can write static concrete methods in interface. 
  we can write a static main method inside interface and the code compiles successfully.

5.Java8 Defined Functional Interfaces -> Predicate, Function, Consumer, Supplier
In Java 8 there is a new package introduced called java.util.function which has 
functional interfaces named Predicate, Function, Consumer, Supplier.
a)Predicate:
->Predicate is used to perform some conditional check and return true or false (boolean value).
->Predicate has single abstract method called test because it is Functional Interface
->If we want to perform conditional checkes and return a boolean value then we should go for predicate
->The Predicate interface is defined as below
@FunctionalInterface
interface Predicate<T>{
	boolean test(T t);
	
	//it has 3 default and 1 static method as well
}
Example of predicate:
public boolean test(Integer i){
	if(i>10){
		return true;
	}
	else{
		return false;
	}
}
we can represent the above in the form of lambda expression because Predicate is functional interface
i -> i>10;   // this is the lambda representation of predicate test method
The above lambda expression gives the Predicate object
Predicate<Integer> predicate = i -> i>10;
S.O.P(predicate.test(5));
Predicate Joining:
We can join two predicate results and form the final predicate from both the prediactes
Example:
Predicate p1 = i -> i>10;  // checkes if the given number is greater or not
Predicate p2 = i -> i%2==0; // checkes if the given number is even or odd
To negate a predicate we can use p1.negate() ->  // checkes if the given number is less or not
To check if both greater and even are true we can join two predicates:
Predicate p3 = p1.add(p2) // checks if both the predicates are true
Predicate p4 = p1.or(p2) // checks if anyone of the predicates is true
Predicate<String> p5 = Predicate.isEqual("Sushanth");
        System.out.println(p5.test("Sushanth")); // returns true
        System.out.println(p5.test("belugula")); // returns false
Note: from the above examples we can consider that
     Predicate Interface contains multiple default methods called negate(), add(), or()
	 Predicate Interface contains one static method called isEqual() it is used to check if the input obj is equal
b)Function:
->Function is used to perform any operations and it can return any data type or any object
->Function has only one single abstract method called apply()
->If we want to perform certain operations and return some value of any data type or object then we should go for function
-The Function interface is defined as below
interface Function<T,R>{
	R apply(T t);
	
	//it has 2 default and 1 static method as well
}
T->is the input type
R->is the return type
Example of Function:
public class Main {
    public static void main(String[] args) {
        Function<String,Integer> f1 = s -> s.length();
        System.out.println(f1.apply("Sushanth"));
    }
}
Function Chaining:
We can chain two Function's and execute them in some order
Consider two Functions f1 and f2 then we can chain them as below
f1.andThen(f2)  // it will execute the f1 first followed by f2
f1.compose(f2)  // it will execute the f2 first followed by f1
Example:
Function<String,String> f1 = s -> s.toUpperCase();
        Function<String,String> f2 = s -> s.substring(0,3);
        System.out.println(f1.apply("Sushanth"));  
        System.out.println(f2.apply("Sushanth"));
        System.out.println(f1.andThen(f2).apply("Sushanth"));
        System.out.println(f2.compose(f1).apply("Sushanth"));
Result:
SUSHANTH
Sus
SUS
SUS
NOTE:From the above examples we can infer that Function interface also has 2 default methods called andThen() and compose() and one static method called identity()
	If we want to get the same function as the return we can use static method called identity()
Ex: Function<String, String> f3 = Function.identity();
        System.out.println(f3.apply("Sushanth"));
c)Consumer:
->Consumer is used to perform any operations and it will not return anything basically it consumes the input
->Consumer has only one abstract method called accept()
->If we want to perform any operations and dosenot return any value then we should go for consumer
->The Consumer interface is defined as below
interface Consumer<T>{
	void accept(T t);
	
	//it has 1 default method as well
}
T-> is the input type
Example:
Consumer<String> c = s -> System.out.println(s);
        c.accept("Sushanth");
Consumer Chaining:
We can chain two Consumer's and execute them in serial order
Consider two Consumer c1 and c2 then we can chain them as below
c1.andThen(c2)  // it will execute the c1 first followed by c2
d)Supplier:
->Supplier is used to perform any opertion to get some data in return it wont accept any inputs
->Supplier has only one abstarct method called get
->If we want to get any data or object without giving any input then we should go for supplier
->The supplier interface is shown as below:
interface Supplier<R>{
	R get();
}
Example:
 Supplier<String> s = () -> {
            String otp = "";
            int randomNumber = 0;
            for (int i=0; i<6; i++){
                randomNumber = (int) (Math.random() * 10);
                otp = otp + randomNumber;
            }
            return otp;
        };
        System.out.println(s.get());
BIPredicate:
->BIPredicate is same as the Predicate but it takes two input
->If we want to perform some conditional checkes on two inputs then we should go for BIPredicate
Example:
BiPredicate<Integer,String> biPredicate = (i,s) -> i==s.length();
System.out.println(biPredicate.test(5,"Sushanth"));

BIFunction:
->BIFunction is same as Function but it has two inputs and one return type-
->If we want to perform some operations on two inputs and return some data then we should go for BiFunction
Example:
BiFunction<Integer, String, Integer> biFunction = (i,s) -> i*s.length();
System.out.println(biFunction.apply(5,"Sushanth"));

BIConsumer:
->BIConsumer is same as Consumer but it has two inputs 
->If we want to perform some operations on two inputs and not return anything then we should go for BIConsumer
Example:
BiConsumer<String,String> biConsumer = (s1,s2) -> System.out.println(s1+" "+s2);
biConsumer.accept("Sushanth", "Belugula");

Primitive Type Functional Interfaces:
primitive date types -> int,byte,long,float,double
wrapper data type -> Integer,Byte,Long,Float,Double
Autoboxing:
Automatic conversion from primitive to wrapper object is called Autoboxing -> example: Integer i = 10
Autounboxing:
Automatic conversion from wrapper object to primitive  is called Autounboxing 
-> example: Integer i = new Integer(10);
			int x = i // performs autounboxing
->The need for primitive types in Functional interfaces is because if we use the Wrapper objects
	while performing any operations the input data needs to be auto boxed or auto unboxed so it will degrade the performace of the application
Example:
public class Main {

    public static void main(String[] args) {
        //List<Integer> integers = Arrays.asList(10,20,5,30,100,45,3);
        int integers[] = {10,20,5,30,100,45,3};
        Predicate<Integer> p1 = i -> i>10; // here we are passing wrapper Integer object but with wrapper object 
											// but we cannot perform arithmetic operations so it will autounbox the wrapper to primitive it will degrade the performance
        Predicate<Integer> p2 = i -> i%2==0;
        System.out.println("Numbers greater than 10 are");
        m1(p1,integers);
	}
		
		public static void m1(Predicate<Integer> predicate, int[] integers){
        for(int i: integers){
            if(predicate.test(i)){    // here we are passing the primitive integer but internally the compiler will autoBox this to a wrapper object Integer this will degrade performance
                System.out.println(i);
            }
        }
    }
}
->From the above example it is clear that if we use Wrapper Object Data types with functional interface's it will degarde the app performance
->So that's the reason why primitive functional interfaces are intoduced

IntPredicate:
->It is same as predicate but it will accept primitive int value as the input
->IntPredicate is represented as below
interface IntPredicate{
	public boolean test(T t);
}
example:
 IntPredicate intPredicate = i -> i%2==0;
in the same way we have LongPredicate, DoublePredicate and so on...
In the same way we have all primitive types for functionals interfaces like Function, Consumer, Supplier

UnaryOperator<T>
A special case of Function<T, T> for same input and output types.
UnaryOperator<String> toUpper = s -> s.toUpperCase();
System.out.println(toUpper.apply("java")); // JAVA

BinaryOperator<T>
A special case of BiFunction<T, T, T> where all types are the same.
BinaryOperator<Integer> sum = (a, b) -> a + b;
System.out.println(sum.apply(5, 3)); // 8


6.Method Reference and constructor reference By using Double Colon(::) operator
Mehtod Reference By using Double Colon(::) operator:
->we can provide implemnation to a abstract method in interface using Method reference also insted of lambda
Example:
Interface I{
public void m1()
}

public class Test{
	public static void m2(){
	s.o.p("Hello")
}
}

public class Main{

	p s v m(String args[]){
        Interface i = () -> s.o.p("Hello"); // -> using lambda
        i.m1()
        Interface i2 = Test::m2()
        i2.m1(); // here m1() referes the m2() method this is called method reference
}
}

NOTE: If we want to use method reference two methods should have same arguments and argument type except this all remaining can be different
Syntax for Method reference:
If referred method(m2) is static mehthod: syntax-> ClassName::methodName
If referred method(m2) is non static mehthod: syntax-> ObjectReference::methodName

Reference to an Instance Method of an Arbitrary Object of a Particular Type
Use when you want to refer to an instance method, but the instance is supplied at runtime (e.g., via stream or collection).
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
// Lambda
names.forEach(name -> System.out.println(name));
// Method reference
names.forEach(System.out::println);


Contsructor Reference using :: operator
->we can provide implemnation to a abstract method in interface using Constructor reference also insted of lambda
Example:
Interface I{
public Sample get();
}

public class Sample{
	Sample(){
	s.o.p("Hello");
	}
}

public class Main{
	p s v m(String args[]){
		Interface i = () -> { Sample s = new Sample()
		return s}; // -> using lambda
		i.get()
		Interface i2 = Sample::new
		i2.get(); // here get method referes the consutructor of Sample class and gets the Sample object
	}
}

7.Streams:
->java.io.Streams is used to perform read and write operations on files
->java.util.Stream is used to perform certian operations on Collection of objects // 1.8 Java
->Streams is used to process the Objects from Collection
->Stream()->Is present in collection interface as a default method
->Stream is an interface comes from java.util.Stream

Filter in stream:
->Filter takes the object of Predicate Functional Interface
->Filter is used to do some conditional checks on the list of objects
Example:
List<Integer) list = Arrays.asList(2,5,8,20,10);
List<Integer) evenList = list.stream().filter(l->l%2==0).collect(Collectors.toList()); // returns list of even numbers

Map in Stream:
->Map is used to apply some Operations on list of objects and map it to the new list of objects
->Map takes Function Functional Interface
Example:
List<Integer) list = Arrays.asList(2,5,8,20,10);
List<Integer) doubledList = list.stream().map(l->l*2).collect(Collectors.toList()); // returns list of doubled numbers

Collect in Stream:
->This mehtod collects the elements from the stream and add it to the specified collection

Count in Stream:
->This is used to find the no of the elements in stream

consider this list for all the below examples List<Integer) list = Arrays.asList(2,5,8,20,10);
Sorted in Stream:
->This method os used to get the sorted order of streams
Sorted() -> for default sorting order
Sorted(Comporater C) -> for customized sorted order
EX:
list.Stream().sorted((i1,i2) -> -i1.compareTo(i2)).collect(Collectors.toList()); // (20,10,8,5,2) descending order

Min and Max in Stream:
-> to get the min or max of a stream according to the specified compartor
ex:
int minValuefromList = list.Stream().min((i1,i2)->i1.compareTo(i2)).get; // 2
int minValuefromList = list.Stream().max((i1,i2)->i1.compareTo(i2)).get; // 20

ForEach in Stream:
->This method takes conusmer Functional Interface object as lambda expression and wont return anything
ex:
list.stream().forEach(i -> System.out::println);

ToArray in Stream:
->This method is used to convert elements in stream to Array

Stream.of() in stream:
->This is used to get a stream for group of values
Stream<Integer> integerStream = Stream.of(2, 5, 8, 4, 20, 45, 9);

8.Date and Time API using JODA API -> joda.org
This JODA Time API is introduced in Java 8 to conviently use Date and Time with more functionality and speed
Example:
LocalDate date = LocalDate.now();
s.o.p(date)
LocalTime time = LocalTime.now();
s.o.p(time)




Method Overriding scope:
When we Override a parent class method then that Overrided method must have the wider access specifier

Access spcefiers from more access to less access: public > protected > default > private

--------------------------------------------------------------------------------------------------------
Ways to convert stream to list:
1. collect(Collectors.toList()) (Java 8+)
Mutable ArrayList keeps encounter order, allows duplicates and nulls
2. collect(Collectors.toUnmodifiableList()) (Java 10+)
Returns an unmodifiable List Disallows null elements; throws NullPointerException if found
3. stream.toList() (Java 16+)
Terminal operation returning an unmodifiable List Allows null elements
More optimized than collect (no extra list copy)
4.collect(Collectors.toCollection(...))
Choose your List implementation, e.g. LinkedList or a pre-sized ArrayList
Example:
List<String> arrayList = stream
    .collect(Collectors.toCollection(ArrayList::new));

List<String> linkedList = stream
    .collect(Collectors.toCollection(LinkedList::new));
------------------------------------------------------------------------------------------------
Ways to convert an array to List
1. Arrays.asList(array)
String[] arr = {"a", "b", "c"};
List<String> list = Arrays.asList(arr);
Returns a fixed-size list backed by the original array
Mutating the list updates the array (and vice versa)
Doesn't support add or remove (throws UnsupportedOperationException)

2. Mutable ArrayList via constructor
List<String> list = new ArrayList<>(Arrays.asList(arr));
Creates a modifiable ArrayList copy
Supports structural modifications (e.g., add, remove)

3. Java 8 Streams
List<Double> list = Arrays.stream(arr).collect(Collectors.toList());
Flexible: allows intermediate operations (filter, map, etc.)
Returns a mutable ArrayList by default

4.List.of() (Java 9+)
List<String> immutable = List.of(arr);
Creates an immutable list
Copies the array (so later changes to arr don’t affect it)
Nulls not allowed; adding/removing elements throws exception
--------------------------------------------------------------------------------------
FlatMap is an intermediate Stream operation:
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
Think of it as: map + flatten.
map transforms each element to a single value.
flatMap transforms each element to a Stream of values and flattens them into one continuous Stream 
Example:
String[] lines = {
    "Hello world",
    "Java flatMap tutorial"
};

List<String> words = Stream.of(lines)
    .flatMap(line -> Arrays.stream(line.split("\\s+")))
    .filter(w -> !w.isBlank())
    .toList(); // ["Hello", "world", "Java", "flatMap", "tutorial"]
	
reduce()?
reduce() is a terminal operation that applies a BinaryOperator to stream elements to collapse them into a single result.
Typical forms:
Optional<T> reduce(BinaryOperator<T> accumulator) — no identity
T reduce(T identity, BinaryOperator<T> accumulator) — with identity
U reduce(U identity, Function<T,U> mapper, BinaryOperator<U> accumulator) — with mapping
It's designed to be associative, enabling parallel processing safely
Example 1: Sum of Integers (With Identity)
List<Integer> nums = List.of(1, 2, 3, 4, 5);
int sum = nums.stream()
              .reduce(0, Integer::sum);
System.out.println(sum); // ➝ 15

Example 2: Longest String (No Identity)
List<String> names = List.of("Alice", "Bob", "Catherine", "Dave");
Optional<String> longest = names.stream()
    .reduce((a, b) -> a.length() > b.length() ? a : b);
longest.ifPresent(System.out::println); // ➝ Catherine
No identity → returns Optional<String> Picks the longer of the two in each pair, finds the maximum by length

--------------------------------------------------------------------------------------
Collectors all Utility methods:
1.Basic Collection
toList() → Collects into a List<T> (typically mutable ArrayList):
List<String> names = stream.collect(Collectors.toList());
toSet() → Collects into a Set<T>, removing duplicates:
Set<T> set = stream.collect(Collectors.toSet());
toCollection(Supplier<C>) → Collects into a custom collection type:
LinkedList<String> ll = stream.collect(Collectors.toCollection(LinkedList::new));

2. String Joining
joining(), joining(CharSequence delim), joining(delim, prefix, suffix)
Concatenates string elements:
List<String> items = Arrays.asList("ONE", "TWO", "THREE");
String s = items.stream()
        .collect(Collectors.joining(", ", "[", "]"));   // joining(delimiter, prefix, suffix) further wraps it in [...].
System.out.println(s); // prints: [ONE, TWO, THREE]

3. Counting, Summation & Averaging
counting() → Long count of stream elements.
summingInt/Long/Double(...) → Sum of mapped numeric values.
averagingInt/Long/Double(...) → Average of mapped numeric values.
summarizingInt/...Long/...Double(...) → Returns summary stats wrapper (IntSummaryStatistics, etc.)
Example Counting:
List<String> names = List.of("Alice", "Bob", "Charlie", "David");
long count = names.stream()
                  .collect(Collectors.counting());
System.out.println("Count of names: " + count); // → 4

Example Summation:
List<Person> people = List.of(
    new Person("Alice", 30),
    new Person("Bob", 25),
    new Person("Charlie", 35)
);
int totalAge = people.stream()
    .collect(Collectors.summingInt(p -> p.age));
System.out.println("Total Age: " + totalAge); // → 90

Example Averaging:
List<Product> products = List.of(
    new Product("Laptop", 800.00),
    new Product("Phone", 600.00),
    new Product("Tablet", 300.00)
);
double avgPrice = products.stream()
    .collect(Collectors.averagingDouble(p -> p.price));
System.out.println("Average Price: " + avgPrice); // → ~566.67

4. Min/Max & Reduction
minBy(Comparator), maxBy(Comparator) → Finds min/max element.
reducing(...) → General-purpose, flexible reduction (with or without identity and combiner).
Example:
List<Integer> numbers = List.of(5, 12, 3, 19, 7);
Optional<Integer> min = numbers.stream()
    .collect(Collectors.minBy(Comparator.naturalOrder()));
// min = Optional[3]
Optional<Integer> max = numbers.stream()
    .collect(Collectors.maxBy(Comparator.naturalOrder()));
// max = Optional[19]

Example reduce
No Identity → Returns Optional
Optional<Integer> diff = Stream.of(5, 10, 20, 50).collect(Collectors.reducing((a, b) -> b - a));
// diff = Optional[35], since (((50 − 20) − 10) − 5) = 15? Actually accumulation: (((5,10)→5),(5,20)→15),(15,50)→35.

With Identity → Returns element type
Integer product = Stream.of(5, 10, 20, 50).collect(Collectors.reducing(1, (a, b) -> a * b));
// product = 5 * 10 * 20 * 50 = 50000

With Mapper + Identity → Transform then reduce
Integer sumOfSquares = Stream.of(1, 2, 3).collect(Collectors.reducing(0, x -> x * x, Integer::sum));
// sumOfSquares = 1 + 4 + 9 = 14

5. Grouping & Partitioning
groupingBy(classifier) → Groups elements in a Map<K, List<T>>.
groupingBy(classifier, downstream) → Nested collection + usual operations.
partitioningBy(Predicate) → Splits into Map<Boolean, List<T>>.
Example:
List<String> words = List.of("a", "bb", "ccc", "dd");
Map<Integer, List<String>> byLength =
    words.stream()
         .collect(Collectors.groupingBy(String::length));

System.out.println(byLength);
// → {1=[a], 2=[bb, dd], 3=[ccc]}


Map<Integer, Set<String>> setByLength =
    words.stream()
         .collect(Collectors.groupingBy(
             String::length,
             Collectors.toSet()
         ));

System.out.println(setByLength);
// → {1=[a], 2=[bb, dd], 3=[ccc]}

Find the longest last name by city:
class Person {
  String city;
  String lastName;
  // constructor/getters
}
Comparator<String> byLength = Comparator.comparing(String::length);

Map<String, String> longestLastNameByCity =
    people.stream().collect(Collectors.groupingBy(
      Person::getCity,
      Collectors.reducing(
        "",                    // identity
        Person::getLastName,  // mapper
        BinaryOperator.maxBy(byLength)
      )
    ));

List<Integer> nums = List.of(1,2,3,4,5,6,7,8,9,10);
Map<Boolean, List<Integer>> evensOdds =
    nums.stream().collect(Collectors.partitioningBy(n -> n % 2 == 0));

System.out.println(evensOdds);
// → {false=[1,3,5,7,9], true=[2,4,6,8,10]}

Map<Boolean, Long> countPartition =
    nums.stream().collect(Collectors.partitioningBy(
      n -> n % 2 == 0,
      Collectors.counting()
    ));

System.out.println(countPartition);
// → {false=5, true=5}



6. Mapping, Filtering & FlatMapping
mapping(mapper, downstream) → Applies a transform within a collect:
stream.collect(Collectors.mapping(String::length, Collectors.toList()));
filtering(predicate, downstream) → Pre-collect filter:
stream.collect(Collectors.filtering(x -> x > 0, Collectors.toList()));
flatMapping(mapper, downstream) → Applies flat-mapping before collecting:
stream.collect(Collectors.flatMapping(list -> list.stream(), Collectors.toList()));

7. Composed/Transformed Builders
collectingAndThen(downstream, finisher) → Applies one final action after collect:
List<String> unmod = stream.collect(
  Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));
teeing(c1, c2, merger) (Java 12+) → Runs two downstream collectors and merges results
stream.collect(Collectors.teeing(
  Collectors.counting(),
  Collectors.summingInt(Integer::intValue),
  (count, sum) -> sum / count));
  
8. To Maps
toMap(keyMapper, valueMapper) → Builds a Map<K, V>, fails on duplicate keys.
Overloaded versions accept merge functions and supplier for different map types.

9. Unmodifiable Collectors
toUnmodifiableList(), toUnmodifiableSet(), toUnmodifiableMap() (Java 10+) → Produce truly immutable structures.

-------------------------------------------------------------------------------------------------------------------------------------
Collector Anatomy (Collector<T,A,R>)
Each Collector defines:
supplier() – Creates an empty result container (e.g., new ArrayList<>()).
accumulator() – Adds an element into the container.
combiner() – Merges two result containers (for parallel streams).
finisher() – Final transformation (identity if not needed).
characteristics() – Metadata about mutability, order, concurrency.
Custom collectors can be created using Collector.of(...)

1.Common Built-in Collectors:
Basic Containers
toList() → List<T>
toSet() → Set<T>
toCollection(...) → Custom Collection
toMap() with value/key mappers (optionally merge function)

Aggregation
counting(), summingInt/Long/Double(...), averagingInt/...()
summarizingInt/Long/Double(...) → returns summary stats (min, max, sum, avg, count) in one pass

Element Selection
maxBy(Comparator) / minBy(Comparator) → Optional<T>
reducing(...) → flexible reduction using identity, accumulator, combiner

String Joining
joining(), with delimiter, prefix, suffix options → concatenates strings

2.Grouping & Partitioning
Groups elements by a classifier Function<T, K> producing a Map<K, List<T>>.
With downstream collectors—for example counting, averaging, summarizing, mapping—to refine the values:
Map<Dept, Long> countByDept = emp.stream()
    .collect(Collectors.groupingBy(Employee::getDept, counting()));
	
partitioningBy(...)
Specialized grouping into two buckets (true / false) based on a Predicate<T>.
Can be combined with a downstream collector:

Custom Collectors via Collector.of(...)
When built-in collectors don’t suffice—e.g. gathering custom statistics or combining multiple metrics—you can define your own:

Collector<Employee, Summary, Summary> summaryCollector =
    Collector.of(
      Summary::new,
      Summary::add,
      Summary::merge,
      Collector.Characteristics.UNORDERED
    );
Summary result = employees.stream().collect(summaryCollector);

Usage Patterns & Tips
Use nested groupingBy for hierarchical reports (e.g. dept → role → salary band).
Partition + downstream is powerful for splitting data and summarizing both subsets.
Mapping + grouping cleanly extracts only needed values.
Use summarizingInt/double when you need multiple statistics in one shot.
Custom collectors with Collector.of avoid multiple stream passes.
On performance: avoid excessive chained collectors or creating large intermediate collections; 
for heavy use consider profiling streams and custom collectors to reduce GC overhead and parallel inefficiencies 
Also, anecdotal advice from dev community emphasizes using 
toMap(Person::getName, identity()) carefully—duplicate keys cause exceptions unless you handle merging explicitly

| Collector                        | Description                                        |
| -------------------------------- | -------------------------------------------------- |
| `toList()`, `toSet()`            | Collect elements into collections                  |
| `toMap(...)`                     | Create map from streams with key/value functions   |
| `counting()`, `summingInt/...`   | Simple statistical aggregates                      |
| `summarizingInt/...`             | Full `summary` statistics object                   |
| `joining(...)`                   | Concatenate strings                                |
| `maxBy()/minBy()`                | Find extreme values with comparator                |
| `reducing(...)`                  | Generic reduction with combining function          |
| `groupingBy(...)`                | Group elements into map by classifier              |
| `partitioningBy(...)`            | Split into `true/false` groups                     |
| `mapping(...)`, `filtering(...)` | Transform or filter elements in grouping (Java 9+) |
| `flatMapping(...)`               | Flatten nested streams when grouping               |
| `Collector.of(...)`              | Define custom collector with full control          |
| `teeing(...)` (Java 12+)         | Combine two downstream collectors in one pass       |

-----------------------------------------------------------------------------------------------------------------------------
Optional class in java 8
Optional<T> (introduced in Java 8) is a container that may—or may not—hold a non-null value. 
It helps avoid NullPointerExceptions and reduces boilerplate null checks, making your code cleaner and more expressive.

1.Creation Methods (Factory Methods)
Optional.of(T value)
Creates an Optional containing a non-null value. Throws NullPointerException if the value is null. 

Optional.ofNullable(T value)
Allows null values; returns an empty Optional if the value is null. 

Optional.empty()
Returns an empty Optional

2.Presence Detection
isPresent()
Returns true if a value is present; otherwise false. 

isEmpty() (Java 11+)
Returns true if no value is present.

3.Value Retrieval & Defaults
get()
Returns the contained value, or throws NoSuchElementException if empty. 

orElse(T other)
Returns the value if present; otherwise returns the other. 

orElseGet(Supplier<? extends T> supplier)
Returns the value if present; otherwise invokes the supplier to compute a value lazily.
 
orElseThrow(Supplier<? extends X> exceptionSupplier)
Returns the value if present; otherwise throws an exception provided by the supplier

4.Functional Transformations
ifPresent(Consumer<? super T> action)
Executes action if a value is present

map(Function<? super T, ? extends U> mapper)
Applies mapper to the value if present and returns an Optional of the result (could be null). 

flatMap(Function<? super T, Optional<U>> mapper)
Similar to map, but expects the mapper to return an Optional, flattening nested Optionals. 

filter(Predicate<? super T> predicate)
Returns the Optional if the value matches the predicate; otherwise, returns empty.
----------------------------------------------------------------------------------------------------------------------------
Interview question.
what is the real world use case of functional interface
Example 1: Currency Conversion – MoneyExchanger
Say you’re building a finance or currency-exchange app. Instead of using a generic Function<Money, Optional<Money>>, 
you can create a self-explanatory, domain-specific interface:
@FunctionalInterface
public interface MoneyExchanger {
    Optional<Money> exchange(Money money);
}
MoneyExchanger idrToEur = money ->
    Optional.ofNullable(money)
            .filter(m -> m.getCurrency() == Currency.IDR)
            .map(m -> new Money(Currency.EUR, 
                m.getAmount().divide(BigDecimal.valueOf(17_000))));
This makes the logic clear—you're “exchanging money.” Naming it MoneyExchanger improves intent and readability 
over a generic Function type-
Example 2: Retry Mechanism – RetryOperation
Imagine you need retry logic for network calls or database transactions. A custom interface could look like:
@FunctionalInterface
interface RetryOperation<T> {
    T execute() throws Exception;
}
RetryOperation<String> retryableOp = () -> {
    int attempts = 0;
    while (attempts < 3) {
        try {
            attempts++;
            // Simulate operation
            if (Math.random() > 0.7) return "Success";
        } catch (Exception e) {
            if (attempts == 3) throw e;
        }
    }
    return "Failed after retries";
};
This cleanly captures the intent—an operation with retry logic—not easily expressed with built-in interfaces.
Why Custom Interfaces Matter
Domain Clarity: Calling MoneyExchanger.exchange() or RetryOperation.execute() 
immediately signals intent in a way Function.apply() or Supplier.get() never could.
Flexibility for Defaults: You can later add domain-relevant default methods (like chained operations) 
without breaking the single-method contract.
Future Enhancements: If you need to introduce logging, metrics, error handling, or composition, custom 
interfaces give a focused extension point that built-ins lack.