Spring core

Fundamentals of Spring Core
1.Dependency Injection (DI) & Inversion of Control (IoC)

a)Inversion of Control (IoC) & Spring IoC Container
IoC Principle: Shifts responsibility of object creation and lifecycle from your code to the Spring framework, 
promoting loose coupling and flexible design.
IoC Containers:
BeanFactory: Lightweight container, lazy-loading beans on demand‚Äîideal for resource-constrained scenarios.
ApplicationContext: Extends BeanFactory with advanced features like eager bean loading, event publishing, 
internationalization, and AOP support.
Why It Matters: IoC enables declarative wiring of beans through configuration metadata, exemplified by 
@Component, @Bean, or XML config, letting Spring control object lifecycles.

b)Dependency Injection (DI)
Concept: A design pattern where dependencies are supplied externally rather than being created internally
Spring handles this automatically.
Injection Types:
Constructor Injection: Dependencies are injected through class constructors‚Äîpromotes immutability and clearer contract.
Setter Injection: Uses setter methods‚Äîallows optional or modifiable dependencies.
Field Injection: Uses @Autowired on fields‚Äîsimple but harder to test and doesn't enforce immutability.

Inversion of Control (IoC) is a broad design principle where the framework or container‚Äînot your application code‚Äîcontrols the flow and object creation.
In other words, ‚ÄúDon‚Äôt call us, we‚Äôll call you.‚Äù 
Dependency Injection (DI) is a specific implementation of this principle: instead of a class instantiating its dependencies internally, 
they are injected into it from an external source (e.g., a framework or container).

Relationship Between IoC and DI
DI is a subset of IoC. Every DI mechanism is a form of IoC, but not all forms of IoC are DI. 
For example, event callbacks or service locators also demonstrate IoC but don‚Äôt count as DI

How it works?
controlling the instantiation or location of its dependencies by using direct construction of classes or 
a mechanism such as the Service Locator pattern.
What is the Service Locator Pattern?
The Service Locator is a design pattern where a central registry (the locator) provides instances of services to clients on demand. A class that needs a service asks the locator rather than instantiating dependencies directly, promoting decoupling from concrete implementations.
Its core components typically include:
Client: the requesting class
Service Locator: central registry that returns services
Cache / Initial Context: locate or instantiate the service, possibly caching results
Service: the actual implementation being retrieved
Service Locator in Bean Initialization & Injection (e.g., Spring)
In frameworks like Spring, the Service Locator pattern is implemented via ServiceLocatorFactoryBean. 
It enables beans to dynamically resolve other beans at runtime. For example, you might define an interface (ParserFactory) 
and Spring handles locating the appropriate parser implementation when needed

->BeanFactory, Application Context, ClassPathXMLAplicationContext, AnnotationConfigApplicationContext
The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework‚Äôs IoC container. 
1. BeanFactory
The core/basic IoC container in Spring, defined in the org.springframework.beans.factory package.
Lazy initialization: Beans are instantiated only when requested via getBean() 
Lightweight: Minimal feature set (no AOP, event publishing, i18n, etc.), making it suitable for memory-constrained 
or simple applications 
Configuration must manually handle BeanPostProcessor and BeanFactoryPostProcessor registration

2. ApplicationContext
A superset of BeanFactory, part of the org.springframework.context package; adds enterprise-ready features 
Eager initialization: All singleton beans are created at startup by default 
Supports internationalization (i18n), event publishing, resource loading, AOP integration, and automatic post-processor registration 
Annotation support is full, whereas BeanFactory supports it only minimally or not at all

3. ClassPathXmlApplicationContext
A concrete implementation of ApplicationContext.
Loads bean definitions from XML configuration files on the classpath 
Commonly used for standalone or non‚Äëweb applications.
Supports features like shutdown hooks (registerShutdownHook()), i18n via MessageSource, and more

4. AnnotationConfigApplicationContext
Also an implementation of ApplicationContext, introduced in Spring 3.0.
Configures beans using Java-based configuration (@Configuration, @Bean, @Component, etc.) instead of XML 
Ideal for modern, annotation-driven, and type-safe configurations.
Can load multiple @Configuration classes and handles overrides gracefully 

-----------------------------------------------------------------------------------------------------------------------------------
2.Beans & IoC Container: Creation, configuration, scopes (singleton, prototype), lifecycle, Java-based and annotation-driven 
configuration, ApplicationContext vs. BeanFactory.

What Is a Bean?
In Spring, a bean definition acts like a recipe: it describes how to create and configure an object in the IoC (Inversion of Control) 
container. The container reads these definitions and then instantiates the beans as needed
Configuration Styles
a). XML-Based Configuration
<bean id="myBean" class="com.example.MyService" scope="singleton">
  <property name="dependency" ref="otherBean"/>
</bean>
b)Annotation & Java-Based Configuration
@Configuration classes define beans through @Bean methods:
@Configuration
public class AppConfig {
   @Bean
   public MyService myService() { ... }
}
Offers better type safety, refactoring support, and IDE assistance over XML.

C)SCOPES
i)Singleton (default): One shared instance per Spring container ‚Äî all requests get the same object
Example:
@Component
@Scope("singleton") // Optional ‚Äî this is default
public class CounterService {
    private int count = 0;

    public void increment() { count++; }
    public int getCount() { return count; }
}

// In usage:
CounterService c1 = context.getBean(CounterService.class);
c1.increment();
CounterService c2 = context.getBean(CounterService.class);
System.out.println(c1 == c2); // true - both refer to same instance

 
ii)Prototype: A new instance is created on each request ‚Äî useful for stateful beans 
Example:
@Component
@Scope("prototype")
public class TreasureMap {
    public TreasureMap() {
        System.out.println("üó∫Ô∏è Treasure Map Created!");
    }
}

iii)Request: instance per HTTP request (web context only) 
Example:
@Component
@Scope(WebApplicationContext.SCOPE_REQUEST)
public class ShipLog { }

iv)Session: instance per HTTP session (web-only) 
Example:
@Component
@Scope(WebApplicationContext.SCOPE_SESSION)
public class PirateSession { }

v)Application: instance per ServletContext ‚Äî shared across the web app scope
Example:
@Component
@Scope("application")
public class GlobalPirateRules { }
 
vi)Websocket: instance per WebSocket session (web-only)
Example:
@Component
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class WebSocketBean { }

Real-World Use Cases
From StackOverflow, here‚Äôs how these scopes translate in practice:
Singleton: Great for stateless services, e.g., a centralized database connection or a service class.
Prototype: Best for stateful objects like form elements, where each use needs a fresh instance.

Prototype vs. Singleton: Injection Gotcha
Injecting a prototype bean into a singleton doesn't behave as you might expect. 
Spring resolves dependencies only once during creation, so the singleton gets just one instance of the prototype. 
To get a fresh prototype at runtime, you'd need method injection or other workaround techniques

Use @Component, @Service, @Repository, or @Controller on classes to enable component scanning with @ComponentScan

‚ÄúSpring creates a proxy for those objects (prototype/session/request)‚Ä¶ during runtime checks against the scope and 
creates the object accordingly.‚Äù
This means your singleton bean can carry a proxy reference, which dynamically resolves to the correct scoped object at runtime.

--------------------------------------------------------------------------------------------------------------------------------------
3.Bean Lifecycle Extensions: @PostConstruct / @PreDestroy, custom initialization, BeanPostProcessor, BeanFactoryPostProcessor.

Spring Bean Lifecycle ‚Äì Step by Step
Step-1. Metadata Processing
Spring starts by reading bean definitions from configuration sources (annotations, XML, Java config), creating BeanDefinition objects. 

Step-2. Instantiation
The container instantiates the bean using its constructor or factory method. 

Step-3. Aware Interfaces (Optional)
If your bean implements any Aware interfaces (e.g., BeanNameAware, ApplicationContextAware), 
Spring invokes their setter methods, allowing beans to access context features. 

Step-4. Dependency Injection
Dependencies are injected into bean properties via setter, constructor, or field injection. 

Step-5. BeanPostProcessor ‚Äì Before Initialization
Any registered BeanPostProcessor can apply logic before initialization callbacks. 
This is helpful for additional checks or proxy wrapping. 

Step-6. Initialization Callbacks
Spring triggers three possible initialization mechanisms in order:
Method annotated with @PostConstruct
afterPropertiesSet() if the bean implements InitializingBean
Custom init method defined (e.g., via init() or initMethod in @Bean) 

Step-7. BeanPostProcessor ‚Äì After Initialization
Additional bean post-processing for operations like AOP proxying occurs now. 
Step-8. Bean Ready for Use
The fully-initialized bean is now available for use within your application. 
Step-9. Destruction Phase
When the application context shuts down (for singleton beans):
@PreDestroy methods are called
destroy() if the bean implements DisposableBean
Custom destroy methods (destroyMethod in @Bean or XML) 
Note: For prototype-scoped beans, destruction callbacks are not invoked‚Äîcleanup must be handled manually

BeanPostProcessor: before & after initialization
What it does:
postProcessBeforeInitialization(bean, beanName): Invoked after dependency injection but before any initialization callbacks 
like @PostConstruct, afterPropertiesSet(), or custom init-method‚Äîletting you modify or wrap the bean early.
postProcessAfterInitialization(bean, beanName): Called after all initialization callbacks, often used to wrap beans 
with proxies (e.g. for AOP).
A proxy is essentially a stand-in or placeholder for another object. It implements the same interface as the real object and 
controls interactions‚Äîacting as an intermediary that can add logic either before or after forwarding calls

Real-world usage:
Before Initialization: Validate properties or perform preparation.
After Initialization: Wrap the bean in a proxy (e.g. for logging or transaction management).

Initialization callbacks
Spring supports three mechanisms for bean initialization callbacks:
@PostConstruct ‚Äì Annotation-based callback that's called after dependency injection (preferred in modern apps).
InitializingBean.afterPropertiesSet() ‚Äì Spring interface-based callback.
init-method="..." ‚Äì XML-specified callback method name.

Real-Time Use Case: Managing Resources in a Database Connection Pool
Imagine you have a bean that wraps a database connection pool or client, such as to an external message queue or file resource. 
You need to ensure that connections are properly initialized when the bean is created, and critically, that the resources are 
cleaned up when your application shuts down.

-------------------------------------------------------------------------------------------------------------------------------------
4.Auto-wiring & Configuration Styles: Usage of @Component, @Service, @Repository, @Controller, @Autowired, @Qualifier, @Primary, 
Stereotype Annotations and @Value; plus profiles and SpEL expressions.
Spring uses stereotype annotations to mark and auto-detect beans based on their layer or purpose. 
All of these are specialized forms of @Component:
@Component ‚Äî a generic stereotype to register any class as a Spring bean during component scanning. 
@Service ‚Äî indicates a service-layer class, encapsulating business logic. 
@Repository ‚Äî marks a data access or repository class; enables exception translation for data operations. 
@Controller ‚Äî a web controller in MVC; handles HTTP requests as part of the presentation layer.
Using these instead of plain @Component gives Spring semantic context‚Äîfor tooling, AOP, exception translation, and clearer architecture.

Dependency Injection: @Autowired, @Qualifier, @Primary
@Autowired
The core annotation to auto-wire dependencies Spring resolves the injection by type for fields, constructors, or method
Resolving Conflicts with Multiple Candidates:
1.@Primary
Marks a default bean when multiple beans of the same type exist. If no qualifier is specified, Spring injects the primary bean

-----------------------------------------------------------------------------------------------------------------------------------------
5.Factory Beans & Aware Interfaces: Using FactoryBean for complex bean creation, and lifecycle awareness with Aware interfaces
1. FactoryBean in Spring
A FactoryBean<T> is a special type of Spring bean that acts as a factory for creating other objects rather than 
being directly used as a bean in your application.
Essential methods to implement:
T getObject()	Returns the actual object to be used by Spring clients.
Class<?> getObjectType()	Indicates the type of object being produced.
boolean isSingleton()	Defines whether the produced object should be a singleton.

When to use FactoryBean:
For complex object creation logic, conditional setup, or post-processing needs.
To integrate third-party libraries that don't fit smoothly into normal Spring DI.
To generate proxies for AOP, transaction management, or feature-flag-driven bean selection.

Use-case examples:
A custom DataSourceFactoryBean dynamically assembling database connections.
ProxyFactoryBean for creating AOP-enabled proxies.
Feature-flagged beans enabled via a FeatureFlagFactoryBean.

2. Aware Interfaces in Spring
Spring provides several Aware interfaces that enable beans to access container-specific information or services through callback methods. Some common interfaces include:

BeanNameAware ‚Äì Receives the bean's name defined in the container.
BeanFactoryAware ‚Äì Gets access to the BeanFactory that created the bean.
ResourceLoaderAware, ApplicationContextAware, etc. ‚Äì Provide access to more advanced functionality like resource 
loading or context features.

Typical use cases:
Logging or internal wiring based on bean name (BeanNameAware).
Legacy integration requiring dynamic lookup of beans (BeanFactoryAware).
Accessing external resources like files or messages via loader or context awareness.

Invocation order during bean initialization:
Spring calls these Aware methods in this sequence as part of bean lifecycle processing:

BeanNameAware.setBeanName(...)
BeanClassLoaderAware.setBeanClassLoader(...)
BeanFactoryAware.setBeanFactory(...)

--------------------------------------------------------------------------------------------------------------------------------------
JSR Annotations:
JSR (Java Specification Request) annotations are standardized metadata annotations in Java that define common concepts across 
various Java technologies. They provide a declarative way to specify behaviors and constraints, enhancing code clarity and enabling
 tools to perform static analysis, validation, and other tasks.
 
JSR 250: Common Annotations for the Java Platform
JSR 250 defines annotations that address common semantic concepts and can be used across Java SE and Java EE components. 
These annotations are now part of the jakarta.annotation package
@PostConstruct	Marks a method to be executed after dependency injection is done.
@PreDestroy	Marks a method to be executed before the instance is removed from the container.
@Resource	Declares a reference to a resource, such as a database connection.
@Resources	Container for multiple @Resource annotations.
@Autowired (Spring) injects by type by default.
@ManagedBean	Indicates that a class is a managed bean.
@RunAs	Defines the role of the application during execution in a Java EE container.
@RolesAllowed	Specifies the security roles permitted to access method(s) in an application.
@Priority	Specifies the priority of interceptors or decorators.
@Generated	Indicates that the annotated element was generated by a tool.
These annotations facilitate lifecycle management, resource injection, and security role definitions in Java applications

Diff b/w Resource and Autowired
@Resource defaults to by-name injection first, then by type.
@Autowired (Spring) injects by type by default. (not JSR)

JSR 303: Bean Validation 1.0
JSR 303 introduces a framework for validating JavaBeans using annotations. It allows developers to define constraints on 
bean properties and validate them at runtime
Annotation	Description
@NotNull	Ensures the annotated element is not null.
@AssertTrue	Ensures the annotated element is true.
@AssertFalse	Ensures the annotated element is false.
@Size	Specifies the size constraints for a string, collection, map, or array.
@Min	Specifies the minimum value for a numeric element.
@Max	Specifies the maximum value for a numeric element.
@Pattern	Specifies a regular expression that the annotated string must match.
@Email	Ensures the annotated string is a valid email address.
@NotEmpty	Ensures the annotated string, collection, map, or array is not empty.
@NotBlank	Ensures the annotated string is not null and the trimmed length is greater than zero.
These annotations are commonly used in Java EE and Spring applications to enforce data integrity and validation rules.

JSR 330: Dependency Injection for Java
JSR 330 defines annotations for dependency injection in Java, aiming to provide a standard set of annotations for DI frameworks
@Inject	Specifies that a constructor, field, or method should be injected with a dependency.
@Named	Specifies the name of the bean to be injected.
@Qualifier	Specifies a qualifier for the injection.
@Singleton	Specifies that the annotated class is a singleton.
@Scope	Specifies the scope of the bean.
@Produces	Specifies a method that produces a bean.
@Disposes	Specifies a method that disposes of a bean.
These annotations are widely used in frameworks like Spring and Jakarta EE to manage object creation and dependency resolution

@Inject vs @Autowired
Both annotations are interpreted by Spring's AutowiredAnnotationBeanPostProcessor, so in practice they work almost identically
@Autowired: Spring-specific.
@Inject: Standard, portable across frameworks like Guice and Jakarta CDI.
required Attribute
@Autowired has a required flag (default true), allowing optional injection (required=false).
@Inject does not support this flag‚Äîabsence of a matching bean causes an exception

JSR 305: Annotations for Software Defect Detection
JSR 305 defines annotations that assist tools in detecting software defects, particularly related to nullability and thread safety
@Nonnull	Indicates that a parameter, return value, or field should not be null.
@Nullable	Indicates that a parameter, return value, or field can be null.
@Immutable	Indicates that a class is immutable.
@ThreadSafe	Indicates that a class is thread-safe.
@NotThreadSafe	Indicates that a class is not thread-safe.
@WillClose	Indicates that a resource will be closed.
These annotations are used to provide additional information to static analysis tools, helping to identify potential issues in the code.

--------------------------------------------------------------------------------------------------------------------------------------------------
Spring Core Annotations
@Component ‚Äî Marks a class as a Spring-managed bean.
@Service ‚Äî Specialized component for business logic.
@Repository ‚Äî Specialized component for data access with exception translation.
@Controller ‚Äî Marks a class as a web MVC controller.
@Configuration ‚Äî Indicates a class containing @Bean definitions.
@Bean ‚Äî Defines a bean method inside a @Configuration class. 
@Autowired ‚Äî Injects dependencies by type. 
@Qualifier ‚Äî Disambiguates which bean to inject when multiple candidates exist. 
@Value ‚Äî Injects external property values or SpEL expressions. 
@Primary ‚Äî Marks a bean as preferred when multiple candidates exist. 
@Scope ‚Äî Defines bean scope (singleton, prototype, etc.). 
@Lazy ‚Äî Enables lazy initialization of beans.
Example (Simple Lazy Bean)
@Configuration
public class AppConfig {
  
  @Bean
  @Lazy
  public ExpensiveService expensiveService() {
    return new ExpensiveService();
  }
 
}
Here, ExpensiveService won't be created until it's accessed by ApplicationService
Example (Lazy at Injection Point)
@Component
public class Region {
  
  @Lazy
  @Autowired
  private City city;

  public City getCityInstance() {
    return city;
  }
}
City is only created when getCityInstance() is invoked
@DependsOn ‚Äî Ensures specified beans are initialized before the annotated one. 
Example:
@Configuration
public class Config {

  @Bean
  @DependsOn({"fileReader", "fileWriter"})
  public FileProcessor fileProcessor() {
    return new FileProcessor();
  }

  @Bean
  public FileReader fileReader() { return new FileReader(); }

  @Bean
  public FileWriter fileWriter() { return new FileWriter(); }
}

@PostConstruct ‚Äî Runs method after dependency injection. 
@PreDestroy ‚Äî Runs method before bean destruction

----------------------------------------------------------------------------------------------------------------------------------------
Spring MVC:
Annotations in spring MVC
@RequestMapping ‚Äî Maps HTTP requests to handler methods.
General-purpose annotation for mapping HTTP requests to controller methods. Usable at both class and method level
Key Attributes:
value or path: Defines URI patterns.
method: Specifies HTTP methods like GET, POST, etc.
params: Matches requests with specific query parameters.
headers: Filters by header values.
consumes: Matches request Content-Type.
produces: Matches expected response Accept head
@GetMapping Retrieve data‚Äîread-only operations. Listing items, fetching resource details, search filtering.
@PostMapping Create new resources or process form submissions. User registration, uploads, data submission.
@PutMapping Replace or fully update an existing resource.Updating whole objects or records.
@DeleteMapping Remove or delete a resource.Removing items by ID or bulk deletes.
@PatchMapping  Apply partial updates to a resource. Updating specific fields rather than the entire resource.
@RestController ‚Äî Combines @Controller with @ResponseBody. 
@ResponseBody ‚Äî Serializes method return value directly into HTTP response.
@RequestParam ‚Äî Binds HTTP request parameters to method arguments. 
Example:
@GetMapping(value = "/search", params = "q")
public String search(@RequestParam String q) { ... }
@PathVariable ‚Äî Binds URI path variables to method parameters. 
Example:
@GetMapping("/books/{isbn:[0-9]+}")
public Book getByIsbn(@PathVariable String isbn)
@RequestBody ‚Äî Binds HTTP request body to a Java object. 
@ModelAttribute ‚Äî Binds request attributes and adds to the model or populates model for views. This is used in 2 ways
A) Binding Form Data to Objects (Method Parameter)
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet,BindingResult result) {}
B) Adding Attributes to the Model Before Handling Requests (Method-Level)
@ModelAttribute("user")
public User setupUserForm() {
    return new User();
}					
@ExceptionHandler ‚Äî Handles specific exceptions in controllers. 
A)Controller-Level Exception Handling
  @RequestMapping("/getData")
    public ModelAndView getData() {
        // ... service call that might throw MyDataException ...
    }

    @ExceptionHandler(MyDataException.class)
    public String handleError(MyDataException e) {
        return "redirect:/showError.html";
    }
	If getData() throws MyDataException, the handleError method triggers and issues a client-side redirect to an error page.
	WE can have multiple exception handlers in a single controller
B)Global Handling with @ControllerAdvice
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoSuchCustomerExistsException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    @ResponseBody
    public ErrorResponse handleException(NoSuchCustomerExistsException ex) {
        return new ErrorResponse(HttpStatus.NOT_FOUND.value(), ex.getMessage());
    }
}
for REST Specification
@RestControllerAdvice
public class MyGlobalExceptionHandler {

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(CustomException1.class)
    public void handleException() {
        // return 400 BAD REQUEST with an empty body
    }
}
@ResponseStatus ‚Äî Sets HTTP status code for responses or exceptions. 
@CrossOrigin ‚Äî Enables Cross-Origin Resource Sharing

@GetMapping(value = "/secure", headers = "X-Auth-Token")
public String secureEndpoint() { ... }
These help route based on query parameters and HTTP headers

Content Negotiation: consumes & produces
consumes: Matches Content-Type of incoming request (e.g. "application/json").
produces: Filters methods that return specific media types based on the Accept header
Method-level definitions override class-level ones.

. Interceptors
Role: Allow pre-processing and post-processing of requests. 
They can be used for tasks such as logging, authentication, and modifying the model.
Example:
public class LoggingInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("Request received: " + request.getRequestURI());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("Response sent: " + response.getStatus());
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("Request and Response completed");
    }
}
