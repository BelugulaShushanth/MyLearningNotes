What is a thread?
A thread is a lightweight sub-process, the smallest unit of processing. 
Multiprocessing and multithreading, both are used to achieve multitasking.

Multithreading in Java is a process of executing multiple threads simultaneously.

Advantages of Java Multithreading
1) It doesn't block the user because threads are independent and you can perform multiple operations at the same time.
2) You can perform many operations together, so it saves time.
3) Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

Multitasking
Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU.
Multitasking can be achieved in two ways:

->Process-based Multitasking (Multiprocessing)
->Thread-based Multitasking (Multithreading)

1) Process-based Multitasking (Multiprocessing)
->Each process has an address in memory. In other words, each process allocates a separate memory area.
->A process is heavyweight.
->Cost of communication between the process is high.
->Switching from one process to another requires some time for saving and loading registers, 
memory maps, updating lists, etc.

2) Thread-based Multitasking (Multithreading)
->Threads share the same address space.
->A thread is lightweight.
->Cost of communication between the thread is low.

How to achieve thread in java?

=>Java Thread class
->Java provides Thread class to achieve thread programming. 
->Thread class provides constructors and methods to create and perform operations on a thread. 
->Thread class extends Object class and implements Runnable interface.

Some important method in Thread class

start()	It is used to start the execution of the thread.
run()	It is used to do an action for a thread.
sleep()	It sleeps a thread for the specified amount of time.
currentThread()	It returns a reference to the currently executing thread object.
join()	It waits for a thread to die.
getPriority()	It returns the priority of the thread.
setPriority()	It changes the priority of the thread.
getName()	It returns the name of the thread.
setName()	It changes the name of the thread.
getId()	It returns the id of the thread.
isAlive()	It tests if the thread is alive
yield()	It causes the currently executing thread object to pause and allow other threads to execute temporarily.
suspend()	It is used to suspend the thread.
resume()	It is used to resume the suspended thread.
stop()	It is used to stop the thread.
destroy()	It is used to destroy the thread group and all of its subgroups.
isDaemon()	It tests if the thread is a daemon thread.
setDaemon()	It marks the thread as daemon or user thre
interrupt()	It interrupts the thread.
isinterrupted()	It tests whether the thread has been interrupted.
Find more here: https://www.javatpoint.com/multithreading-in-java

How to create a thread in Java
There are two ways to create a thread:

->By extending Thread class
->By implementing Runnable interface.

=>Thread class:
Thread class provide constructors and methods to create and perform operations on a thread.
Thread class extends Object class and implements Runnable interface.

=>Runnable interface:
The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.
Runnable interface have only one method named run().

=>Starting a thread:
The start() method of Thread class is used to start a newly created thread.
It performs the following tasks:
A new thread starts(with new callstack).
The thread moves from New state to the Runnable state.
When the thread gets a chance to execute, its target run() method will run.

=>Thread Scheduler in Java
A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java. 
In Java, a thread is only chosen by a thread scheduler if it is in the runnable state. 
However, if there is more than one thread in the runnable state, 
it is up to the thread scheduler to pick one of the threads and ignore the other ones. 
There are some criteria that decide which thread will execute first. 
There are two factors for scheduling a thread i.e. Priority and Time of arrival.

->Priority: 
Priority of each thread lies between 1 to 10. If a thread has a higher priority,
it means that thread has got a better chance of getting picked up by the thread scheduler.

->Time of Arrival: 
Suppose two threads of the same priority enter the runnable state, 
then priority cannot be the factor to pick a thread from these two threads. 
In such a case, arrival time of thread is considered by the thread scheduler. 
A thread that arrived first gets the preference over the other threads.

=>Thread Scheduler Algorithms
On the basis of the above-mentioned factors, the scheduling algorithm is followed by a Java thread scheduler.

1.First Come First Serve Scheduling:
In this scheduling algorithm, the scheduler picks the threads that arrive first in the runnable queue.

2.Time-slicing scheduling:
Usually, the First Come First Serve algorithm is non-preemptive, which is bad as it may lead to infinite blocking
(also known as starvation). To avoid that, some time-slices are provided to the threads so that after some time, 
the running thread has to give up the CPU. Thus, the other waiting threads also get time to run their job.

3.Preemptive-Priority Scheduling:
The name of the scheduling algorithm denotes that the algorithm is related to the priority of the threads.
Suppose there are multiple threads available in the runnable state. 
The thread scheduler picks that thread that has the highest priority. 
Since the algorithm is also preemptive, therefore, time slices are also provided to the threads to avoid starvation. 
Thus, after some time, even if the highest priority thread has not completed its job, 
it has to release the CPU because of preemption.

=>Working of the Java Thread Scheduler:
Let's understand the working of the Java thread scheduler. 
Suppose, there are five threads that have different arrival times and different priorities. 
Now, it is the responsibility of the thread scheduler to decide which thread will get the CPU first.

The thread scheduler selects the thread that has the highest priority, and the thread begins the execution of the job. 
If a thread is already in runnable state and another thread (that has higher priority) reaches in the runnable state, 
then the current thread is pre-empted from the processor, and the arrived thread with higher priority gets the CPU time.
When two threads (Thread 2 and Thread 3) having the same priorities and arrival time, 
the scheduling will be decided on the basis of FCFS algorithm. 
Thus, the thread that arrives first gets the opportunity to execute first.

=>Thread.sleep() in Java
The Java Thread class provides the two variant of the sleep() method. 
First one accepts only one argument, whereas the other variant accepts two arguments. 
The method sleep() is being used to halt the working of a thread for a given amount of time. 
The time up to which the thread remains in the sleeping state is known as the sleeping time of the thread. 
After the sleeping time is over, the thread starts its execution from where it has left.

public static void sleep(long mls) throws InterruptedException   
public static void sleep(long mls, int n) throws InterruptedException

mls: The time in milliseconds is represented by the parameter mls. The duration for which the thread will sleep
	is given by the method sleep().

n: It shows the additional time up to which the programmer or developer wants the thread to be in the sleeping state. 
	The range of n is from 0 to 999999.

=>Can we start a thread twice
No. After starting a thread, it can never be started again. 
If you does so, an IllegalThreadStateException is thrown. 
In such case, thread will run once but for second time, it will throw exception.

=>What if we call Java run() method directly instead start() method?
Each thread starts in a separate call stack.
Invoking the run() method from the main thread, 
the run() method goes onto the current call stack rather than at the beginning of a new call stack.

=>Thread join() method
join(): When the join() method is invoked, the current thread stops its execution and the thread goes into the wait state. 
The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state. 
If interruption of the thread occurs, then it throws the InterruptedException.

Syntax: Syntax: public final void join() throws InterruptedException  

join(long mls): 
When the join() method is invoked, the current thread stops its execution and the thread goes into the wait state. 
The current thread remains in the wait state until the thread on which the join() method is invoked called is dead
or the wait for the specified time frame(in milliseconds) is over.
 
Syntax: public final synchronized void join(long mls) throws InterruptedException, where mls is in milliseconds  
OR public final synchronized void join(long mls, int nanos) throws InterruptedException, where mls is in milliseconds.  

Priority of a Thread (Thread Priority)
Each thread has a priority. Priorities are represented by a number between 1 and 10. 
In most cases, the thread scheduler schedules the threads according to their priority (known as preemptive scheduling). 
But it is not guaranteed because it depends on JVM specification that which scheduling it chooses. 
Note that not only JVM a Java programmer can also assign the priorities of a thread explicitly in a Java program.

public final int getPriority(): The java.lang.Thread.getPriority() method returns the priority of the given thread.

public final void setPriority(int newPriority): The java.lang.Thread.setPriority() method updates or assign the priority
of the thread to newPriority. The method throws IllegalArgumentException if the value newPriority goes out of the range, 
which is 1 (minimum) to 10 (maximum)

3 constants defined in Thread class:
public static int MIN_PRIORITY
public static int NORM_PRIORITY
public static int MAX_PRIORITY

Default priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.

=>Daemon Thread in Java
Daemon thread in Java is a service provider thread that provides services to the user thread. 
Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.

There are many java daemon threads running automatically e.g. gc, finalizer etc.
You can see all the detail by typing the jconsole in the command prompt. 
The jconsole tool provides information about the loaded classes, memory usage, running threads etc.

Points to remember for Daemon Thread in Java
->It provides services to user threads for background supporting tasks. It has no role in life than to serve user threads.
->Its life depends on user threads.
->It is a low priority thread.

Why JVM terminates the daemon thread if there is no user thread?
The sole purpose of the daemon thread is that it provides services to user thread for background supporting task. 
If there is no user thread, why should JVM keep running this thread. 
That is why JVM terminates the daemon thread if there is no user thread

public void setDaemon(boolean status)	is used to mark the current thread as daemon thread or user thread.
public boolean isDaemon()	is used to check that current is daemon.

=>Java Thread Pool
Java Thread pool represents a group of worker threads that are waiting for the job and reused many times.
In the case of a thread pool, a group of fixed-size threads is created. 
A thread from the thread pool is pulled out and assigned a job by the service provider. 
After completion of the job, the thread is contained in the thread pool again.

=>Thread Pool Methods
newFixedThreadPool(int s): The method creates a thread pool of the fixed size s.

newCachedThreadPool(): The method creates a new thread pool that creates the new threads when needed but will still
						use the previously created thread whenever they are available to use.
						
=>Advantage of Java Thread Pool
Better performance It saves time because there is no need to create a new thread.

=>Real time usage
It is used in Servlet and JSP where the container creates a thread pool to process the request

Syntax: ExecutorService executor = Executors.newFixedThreadPool(5);//creating a pool of 5 threads

=>Risks involved in Thread Pools:
Deadlock: It is a known fact that deadlock can come in any program that involves multithreading, 
and a thread pool introduces another scenario of deadlock. Consider a scenario where all the threads that 
are executing are waiting for the results from the threads that are blocked and waiting in the queue because 
of the non-availability of threads for the execution.

Thread Leakage: Leakage of threads occurs when a thread is being removed from the pool to execute a task
but is not returning to it after the completion of the task. For example, when a thread throws the exception
and the pool class is not able to catch this exception, then the thread exits and reduces the thread pool size by 1. 
If the same thing repeats a number of times, then there are fair chances that the pool will become empty, and hence, 
there are no threads available in the pool for executing other requests.

Resource Thrashing: A lot of time is wasted in context switching among threads when the size of the thread pool
is very large. Whenever there are more threads than the optimal number may cause the starvation problem, 
and it leads to resource thrashing

ThreadGroup in Java
Java provides a convenient way to group multiple threads in a single object. In such a way, we can suspend, 
resume or interrupt a group of threads by a single method call.

Java thread group is implemented by java.lang.ThreadGroup class.

A ThreadGroup represents a set of threads. A thread group can also include the other thread group. 
The thread group creates a tree in which every thread group except the initial thread group has a parent.

A thread is allowed to access information about its own thread group, but it cannot access the information 
about its thread group's parent thread group or any other thread groups.

Check in Detail: https://www.javatpoint.com/threadgroup-in-java

=>Java Shutdown Hook
A special construct that facilitates the developers to add some code that has to be run when the Java Virtual Machine 
(JVM) is shutting down is known as the Java shutdown hook. The Java shutdown hook comes in very handy in the cases
where one needs to perform some special cleanup work when the JVM is shutting down. Note that handling an operation 
such as invoking a special method before the JVM terminates does not work using a general construct when the JVM is 
shutting down due to some external factors. For example, whenever a kill request is generated by the operating system 
or due to resource is not allocated because of the lack of free memory, then in such a case, it is not possible to 
invoke the procedure. The shutdown hook solves this problem comfortably by providing an arbitrary block of code.

=>Java Garbage Collection
In java, garbage means unreferenced objects.
Garbage Collection is process of reclaiming the runtime unused memory automatically. 
In other words, it is a way to destroy the unused objects.

To do so, we were using free() function in C language and delete() in C++. 
But, in java it is performed automatically. So, java provides better memory management.

=>Advantage of Garbage Collection
It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory.
It is automatically done by the garbage collector(a part of JVM) so we don't need to make extra efforts.

How can an object be unreferenced?
->By nulling the reference
->By assigning a reference to another
->By anonymous object etc.

=>finalize() method
The finalize() method is invoked each time before the object is garbage collected. 
This method can be used to perform cleanup processing. 
This method is defined in Object class as:protected void finalize(){}

=>gc() method
The gc() method is used to invoke the garbage collector to perform cleanup processing. 
The gc() is found in System and Runtime classes.
public static void gc(){} 

Example:
public class TestGarbage1{  
 public void finalize(){System.out.println("object is garbage collected");}  
 public static void main(String args[]){  
  TestGarbage1 s1=new TestGarbage1();  
  TestGarbage1 s2=new TestGarbage1();  
  s1=null;  
  s2=null;  
  System.gc();  
 }  
}  


=>Java Runtime class
Java Runtime class is used to interact with java runtime environment. 
Java Runtime class provides methods to execute a process, invoke GC, get total and free memory etc. 
There is only one instance of java.lang.Runtime class is available for one java application.

The Runtime.getRuntime() method returns the singleton instance of Runtime class.

Important methods of Java Runtime class
1)	public static Runtime getRuntime()	returns the instance of Runtime class.
2)	public void exit(int status)	terminates the current virtual machine.
3)	public void addShutdownHook(Thread hook)	registers new hook thread.
4)	public Process exec(String command)throws IOException	executes given command in a separate process.
5)	public int availableProcessors()	returns no. of available processors.
6)	public long freeMemory()	returns amount of free memory in JVM.
7)	public long totalMemory()	returns amount of total memory in JVM.
