ClassLoader Substem:
The Java Class Loader Subsystem is a critical component of the 
Java Virtual Machine (JVM) responsible for dynamically(lazy) loading classes during runtime. 
It ensures that classes are loaded only when needed, facilitating efficient memory management and 
supporting features like reflection and dynamic class loading.

Class Loading Process
The class loading process involves three main phases:
Loading: The JVM locates and reads the binary data of a class, typically from a .class file or a JAR archive.
Linking: This phase includes:
	Verification: Ensures the bytecode adheres to JVM specifications and is safe to execute.
	Preparation: Allocates memory for class variables and sets them to default values.
	Resolution: Replaces symbolic references in the class with direct references to other classes and methods
Initialization: Static variables are assigned their proper values, and static blocks are executed in the order they appear in the source code

Bootstrap Class Loader: The foundational class loader, written in native code, 
loads core Java libraries located in the <JAVA_HOME>/jre/lib directory.
Extension Class Loader: Loads classes from the extension directories specified by the java.ext.dirs system property.
System/Application Class Loader: Loads classes from the application's classpath, 
typically defined by the CLASSPATH environment variable.

Delegation Model
When a class is requested:
Ask Bootstrap ClassLoader if it can load it.
If not, delegate to Platform ClassLoader.
If still not found, the System ClassLoader tries.
Only then does a custom loader get invoked if used. 
This ensures consistency (one class definition), security (prevent overriding system classes), and predictability

1. What Is loadClass()?
Purpose: It's the main entry point for class loading. The JVM calls loadClass() to resolve class references.
Process (Delegation Model):
Checks if the class is already loaded via findLoadedClass().
Delegates to the parent class loader if not found.
Finally, calls findClass() if still not found.
If the resolve flag is true, it then calls resolveClass() to link the class.
Recommendation: Subclasses should not override this method—stick with findClass() for custom logic.

2. What Is findClass()?
Purpose: Provides the actual mechanism to locate and define a class—typically from a custom source (
e.g., file system, network, encrypted storage).
Usage: Invoked only after loadClass() fails to find a class via delegation.
Custom Implementation: Subclasses are expected to override this. They typically:
Read class bytes,
Optionally define package metadata,
Use defineClass() to turn bytes into a Class<?> instance.
Default Behavior: Throws ClassNotFoundException if not overridden.

| Method        | Role                              | Who Calls It                         | Typical Behavior                                                                             |
| ------------- | --------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------- |
| `loadClass()` | High-level entry point            | JVM or user code                     | Checks loaded cache, delegates to parent loader, then delegates to `findClass()`             |
| `findClass()` | Custom class locating and loading | Normally overridden by custom loader | Reads bytes (e.g. from custom source), defines class, returns `Class<?>` or throws exception |


Why Use a Custom Class Loader?
You might implement a custom ClassLoader to:
Load classes from non-standard places: e.g., network, encrypted storage, databases.
Enable hot deployment/reloading (e.g., during development or in app servers).
Provide namespace isolation (load multiple versions of classes with the same name, without conflicts).
Support bytecode transformation, such as instrumentation, profiling, mocking, or AOP

How to Write a Custom Class Loader
Recommended Approach: Override findClass()

You should typically override findClass() rather than loadClass():
loadClass() adheres to the delegation model and handles checks for already-loaded classes.
By overriding findClass(), you provide custom loading logic just when the parent loader can't find it. 

public class DirectoryClassLoader extends ClassLoader {
    private final Path directory;
    public DirectoryClassLoader(Path directory, ClassLoader parent) {
        super(parent);
        this.directory = directory;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            Path classFile = directory.resolve(name.replace('.', '/') + ".class");
            if (Files.exists(classFile)) {
                byte[] bytes = Files.readAllBytes(classFile);
                return defineClass(name, bytes, 0, bytes.length);
            }
        } catch (IOException e) {
            throw new ClassNotFoundException("Failed to load", e);
        }
        throw new ClassNotFoundException(name);
    }
}

DirectoryClassLoader loader = new DirectoryClassLoader(
    Paths.get("/custom/classes"), MyApp.class.getClassLoader());
Class<?> cls = loader.loadClass("com.example.MyClass");
Object obj = cls.getDeclaredConstructor().newInstance();

MyApp.class.getClassLoader() ?
If MyApp is part of your application code (i.e., on the classpath or module path), 
the method returns an instance like sun.misc.Launcher$AppClassLoader—the System/Application ClassLoader 
If MyApp belongs to a core Java package (like java.lang), it was loaded by the Bootstrap ClassLoader, 
which isn’t a Java object. In that case, getClassLoader() returns null

Reference Types
Java’s four reference types strong, soft, weak, and phantom
1. Strong References — The Default Choice
The standard references you use every day, e.g.:
MyClass obj = new MyClass();
Garbage Collection Behavior: Objects referenced strongly are never eligible for GC as long as the reference exists. 
Only if you set the reference to null or it goes out of scope can the object be collected. 
When to Use: Use strong references for normal object usage—this is the default and safest behavior that 
ensures objects remain in memory when needed.

2. Soft References — Flexible Caching
Definition: Wrap objects in a SoftReference to hint that they can be reclaimed when memory is tight.
SoftReference<MyObject> softRef = new SoftReference<>(new MyObject());
Garbage Collection Behavior: Softly referenced objects stay in memory until the JVM determines it's running low on memory. 
They’re cleared before an OutOfMemoryError is thrown. 
Use Cases:
Memory-sensitive caches that should hold objects when memory is sufficient.
Large data objects that you’d like to reuse when feasible but can discard if necessary
When to Use: Use soft references to cache expensive-to-recreate data, offering a good balance between retention and memory resilience.

3. Weak References — For Short-Lived or Auxiliary Tracking
Definition: Wrap objects in WeakReference, signaling intent that they can be GC’d quickly:
WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject());
Garbage Collection Behavior: Weakly referenced objects are collected as soon as there are no strong references. 
Use Cases:
WeakHashMap: Automatically removes entries when keys are no longer strongly reachable.
Event listeners or caching metadata: Avoids memory leaks by not holding onto objects longer than needed. 
When to Use: Ideal for structures where you don’t want your reference to prevent object cleanup—like canonicalization maps 
or listeners/observers where cleanup needs to be automatic.

4. Phantom References — Post-GC Cleanup Hooks
Definition: PhantomReference doesn't allow access to the object (always returns null) and requires a ReferenceQueue:
PhantomReference<MyObject> phantomRef = new PhantomReference<>(obj, referenceQueue);
When you create a PhantomReference, you typically register it with a ReferenceQueue. The purpose of this queue is simple: 
it tells your application exactly when the Java garbage collector has finalized an object and it's ready for cleanup. 
Without the queue, you’d have no reliable way to know when to perform cleanup tasks—making PhantomReference effectively useless. 
This is why a PhantomReference without a reference queue is considered pointless—it never gets enqueued, so you'll never know 
it's time to finalize resources.

What Does isEnqueued() Mean?
The isEnqueued() method checks whether the reference has been added to the ReferenceQueue. It returns:
false if the reference hasn't been enqueued yet (i.e., the object isn’t finalized or the GC hasn't processed it).
true once the garbage collector has marked the object for final cleanup and placed the reference into the queue. 
You can use this method to periodically check whether it's time to trigger your cleanup logic.

Behind the Scenes
According to Java’s official documentation:
When the garbage collector identifies an object as phantom reachable (i.e., no strong, soft, or weak references remain), 
it enqueues its PhantomReference to the associated ReferenceQueue. 
This behavior is a powerful alternative to finalize()—it gives you control over cleanup timing and helps you avoid finalize() pitfalls.

| Concept              | Meaning                                                                               |
| -------------------- | ------------------------------------------------------------------------------------- |
| **`ReferenceQueue`** | Receives `PhantomReference` when an object is ready for cleanup.                      |
| **`isEnqueued()`**   | Returns `true` if the reference has been placed on the queue by the GC.               |
| **Purpose**          | Enables precise cleanup after GC finalizes an object—without relying on `finalize()`. |

finalize()
Every Java object inherits a finalize() method from the Object class, which the garbage collector (GC) may invoke once before 
reclaiming the object’s memory. It’s akin to a destructor in other languages—but Java’s implementation is non-deterministic
@Override
protected void finalize() throws Throwable {
    try {
        // cleanup logic
    } finally {
        super.finalize();
    }
}
Pitfalls of Using finalize()
1. Unpredictable Execution
There's no guarantee when—or if—finalize() will be called. The GC may skip it entirely, especially on abrupt termination. 
2. Performance Penalty
Objects with finalizers incur extra GC cycles. This slows performance—sometimes dramatically. 
3. Resource Leak Risks
Because its timing is uncertain, relying on finalize() for closing critical resources (like file or DB connections) often results in resource leaks. 
4. Exception Silencing
If finalize() throws an exception, it's silently swallowed and not propagated or logged. 
5. Subclassing Hazards
Subclasses that override finalize() must call super.finalize() explicitly. 
Failing to do so breaks the cleanup chain; this is easy to overlook
6. Possible Object Resurrection
finalize() may accidentally resurrect objects, bringing them back into a reachable state—adding unintended complexity. 
7. Deprecated and Future Removal
As of Java 9, finalize() is deprecated; Java 18 will remove it altogether (via JEP 421).

| Alternative                         | Description                                                                                               |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Try-With-Resources**              | Auto-closes resources in a reliable, clean, and concise way. ([Java Tech Blog][1])                        |
| **Explicit Cleanup Methods**        | Use `.close()` or `dispose()`, called in `finally` blocks to ensure timely cleanup. ([Java Tech Blog][1]) |
| **`Cleaner` or `PhantomReference`** | Preferred for complex finalization logic in modern Java (9+). ([GeeksforGeeks][2], [JAVAJEE.COM][3])      |

Difference between Class.forName() and ClassLoader.loadClass()
1. Class Initialization Behavior
Class.forName("SomeClass")
Loads and initializes the class—it executes static initializers immediately.
For example, if you have:
class A {
    static { System.out.println("A initialized!"); }
}
Class.forName("A");  // o/p: A initialized!
ClassLoader.loadClass("SomeClass")
Only loads the class definition—it does not initialize it.
 Static blocks won’t run until the class is used (e.g., via instantiation or reflection).
ClassLoader.getSystemClassLoader().loadClass("A"); // o/p : nothing prints
2. ClassLoader Used
Class.forName(String)
Internally delegates to using the class loader of the calling class
Class.forName(className, true, currentLoader)
ClassLoader.loadClass(String)
Uses the explicit ClassLoader instance you invoke it on, 
such as Thread.currentThread().getContextClassLoader() or getSystemClassLoader()
3. Special Case: Array Classes
ClassLoader.loadClass(...) cannot load array class names like "[Ljava.lang.String;".
Whereas Class.forName() can—it handles array names properly via the JVM.

-----------------------------------------------------------------------------------------------------------------------------
Java’s memory model divides memory into several key areas:
1. Stack
The Stack is crucial for managing method execution, storing method call frames, 
local variables, and references to objects in the heap. Each thread has its own stack, 
providing thread isolation and supporting concurrent execution.
Characteristics of the Stack
Local Variables and References: Local variables are stored in the stack. Here’s an example:
public class Main {
    public void methodA() {
        int x = 5; // Stored in the stack
        Car myCar = new Car(); // Reference is in the stack; object is in the heap
    }
}
LIFO Memory Management: The stack follows a Last-In-First-Out (LIFO) approach. 
Each method call adds a stack frame, and the frame is removed when the method completes.
Important Notes:
StackOverflowError: If the stack exceeds its allocated space (e.g., due to infinite recursion), a StackOverflowError occurs (ex: infinite recursion).
Performance: Stack access is faster than heap access due to its simple structure, requiring no garbage collection.

2. Heap
The Heap is the main memory pool for dynamic allocation in Java, storing all objects created during runtime. 
Java’s automatic garbage collection handles memory cleanup when objects are no longer referenced, making the heap essential for long-term storage.

3. Metaspace (Method Area / Class Area)
The Metaspace stores metadata about loaded classes and methods, such as field information, method names, and constants. 
Metaspace offers flexible memory allocation for class metadata.
Characteristics of Metaspace
Class Metadata: Metaspace stores class structures, including field and method information.
Constant Pool: Stores constant values like method names and literals.
Static Variables: static variables and constant data.

Garbage Collection of Metaspace
Unused classes can be unloaded and their memory reclaimed by the JVM when they are no longer referenced. 
This is especially important for applications that load and unload many classes dynamically.

Thread Stack (Call Stack)
Each thread in Java has:
Its own call stack (also known as the execution stack)
This stack stores:
1.Local variables (primitives and object references)
2.Method call frames (for tracking execution)
3.Return addresses and intermediate computations
So when a thread is running, its data (like method-local variables) is stored in the thread's stack, which is private to that thread.

Heap Memory (Shared)
Objects that threads create or reference live in the heap
The heap is shared across all threads
So multiple threads can read/write the same object (which is why we need synchronization!)

+-----------------------------------------------------------+
|                        Heap (Shared)                      |
|  +-------------------+    +----------------------------+  |
|  |  String "Hello"   |    |   MyObject@1234            |  |
|  |  (used by Thread1)|    |   fieldA = 42              |  |
|  +-------------------+    |   fieldB = "shared"        |  |
|                           +----------------------------+  |
|                    (shared across all threads)            |
+-----------------------------------------------------------+

              |                         |
              |                         |
              v                         v

+----------------------+     +----------------------+
|   Thread-1 Stack     |     |   Thread-2 Stack     |
+----------------------+     +----------------------+
| MethodA() frame      |     | MethodX() frame      |
|   int x = 5          |     |   int y = 10         |
|   String s = "Hello" |     |   MyObject obj       |
|   obj -> @1234       |     |   obj -> @1234       |
+----------------------+     +----------------------+

 - Local variables and method calls live in each thread's stack.
 - Object references (e.g., `obj`) point to data in the heap.
 - Heap memory is shared; stacks are private to each thread.

--------------------------------------------------------------------------------------------------------------------------------
Garbage Collection:
Garbage Collection (GC) is Java’s automatic way of reclaiming memory used by objects 
that are no longer reachable by the application. It helps prevent memory leaks and ensures efficient use of heap space.

1. Mark‑Sweep
How it works?
Mark phase: Traverse from GC roots and mark live objects.
Sweep phase: Reclaim memory of unmarked (dead) objects. 

Pros:Simple, requires minimal extra memory (only a mark bit).
Cons:Leads to memory fragmentation, making it hard to allocate large contiguous blocks later.

2. Copying (Mark‑Copy)
How it works?
Split memory into two halves: from-space and to-space.
During GC, copy live objects from the full half to the empty one. Clear the old half and swap roles.

Pros: Eliminates fragmentation since live objects are compacted together. Efficient allocation via simple pointer bumping.
Cons:Uses only half the heap at a time, resulting in high memory overhead

3.Mark‑Compact (Mark‑Sweep‑Compact)
How it works?
Mark live objects (same as Mark-Sweep).
Sweep to identify free areas.
Compact by moving live objects toward one end of the heap.

Update all references to reflect new object locations.

Pros:Combines advantages: no fragmentation + full heap usage.
Cons:Computationally heavier due to relocation and pointer updates, causing longer pause times.

4.Generational Collection Algorithm:
Heap:
┌────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────┐
│                       Young Generation (1/3)               │             Old Generation (2/3)                 │
│    ┌──────────────┬──────────────────┐                     │                                                  │
│    │    Eden      │ From Survivor    │ To Survivor         │                   ...                            │
│    │  (8/10 YG)   │    (1/10 YG)     │    (1/10 YG)        │                                                  │
│    └──────────────┴──────────────────┴───────────────┘     │                                                  │
└────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────┘

Heap space is divided into Young generation (1/3) and Old generation (2/3).
Within the Young generation, memory is further subdivided as follows:
Eden: 8/10 of the Young generation
From Survivor: 1/10 of the Young generation
To Survivor: 1/10 of the Young generation
Thread local allocation buffer (TLAB): This is used to speed up the object allocation in heap(specifically eden)
Each thread gets its own memory region for object creation only—this is about where objects go in memory, not what they do afterward.

1.Young Generation
Eden Space: All new objects are allocated here.
Survivor Spaces: Two equal partitions—From and To. 
After each Minor GC, live objects from Eden and the older Survivor are copied to the other Survivor space, avoiding fragmentation
This repeated process (Eden → To, then To → From, etc.) keeps objects alive temporarily without prematurely moving them to the 
Old Generation. It also ensures one Survivor is always empty, enabling fast copying instead of costly compaction

Why Survivor Spaces?
1.Prevent premature promotion of objects that will soon die.
2.Avoid wasting space and frequent Major GCs.
3.Dual Survivor spaces enable copying GC, which avoids fragmentation by always copying live objects into one clean space

Why Pair of Survivors?
Only two allow one to be “empty” for copying while the other is live.
More than two would mean smaller spaces, higher fill rates, and frequent early promotion

2. Old (Tenured) Generation
Objects that survive multiple Minor GCs (default ~15) or are too big are promoted here 
Old Gen is larger and cleared less frequently during Major or Full GCs, 
which involve more time-consuming operations like Mark-Sweep-Compact.

Promotional Rules:
1.Objects survive ~15 cycles in Young Gen → promote 
2.If Survivor fills up early, objects may be prematurely promoted to Old Gen.
3.Very large objects (based on size threshold) skip Young Gen and go straight to Old Gen 
4.JVM may also use dynamic thresholds if a certain age group dominates Survivor, those objects may be promoted early.

Why This Design?
1.Generational GC takes advantage of the fact that most objects die young, so collecting small regions (Young Gen) is fast and efficient 
2.Survivor spaces lessen unnecessary promotions to Old Gen and avoid heap fragmentation through copy-based GC 
3.Using two Survivor spaces lets the JVM copy to a clean area every cycle, keeping memory contiguous and efficient

Java's Garbage Collectors:
1.Serial GC (-XX:+UseSerialGC)
Young Generation: Single-threaded Copying collector (Eden + Survivor spaces).
Old Generation: Mark‑Compact collector (compacts live objects to avoid fragmentation) 
When to Use: Opt for this when running on single-core machines or when simplicity and low overhead are paramount.

2.Parallel GC (-XX:+UseParallelGC) and Parallel Old GC
Young Generation: Parallel Copying collector using multiple threads.
Old Generation: Parallel Mark‑Compact collector (Parallel Old variant uses multiple threads) 
When to use: Ideal for applications that can tolerate longer pauses but require high throughput, such as batch processing tasks.

3.CMS (Concurrent Mark-Sweep) (-XX:+UseConcMarkSweepGC)
Young Generation: Parallel Copying collector same as Parallel GC.
Old Generation: Concurrent Mark‑Sweep collector that does not compact the old gen; fragmentation may occur. 
When to use: Suitable for applications that need low-latency performance and can handle occasional full GCs. 
Note that CMS is deprecated in Java 9 and removed in Java 14.

4. G1 GC (-XX:+UseG1GC, default since Java 9+)
G1 is a modern GC designed for large heaps (multiple GB) on multiprocessor servers—it became the default GC since Java 9
diveds heap into smaller regions ranging from(1MB to 32MB) 
each of which can be independently assigned as Eden, Survivor, or Old generation memory
Its main goal: predictable pause times (you can set a pause-time goal, e.g. 200 ms) while still cleaning up efficiently
 
Young Generation: Region-based Copying/Evacuating collector (evacuates live objects from Eden + Survivor regions).
Old Generation: Concurrent Mark‑Compact via evacuation of entire regions (compacts high-garbage regions). 
When to use: Recommended for applications with large heaps that require predictable pause times. 
It's the default in Java 9 and later.


5. ZGC (-XX:+UseZGC) and Generational ZGC (-XX:+ZGenerational)
Non-generational ZGC: Treats heap as one, concurrent mark and concurrent compaction, no generational separation.
Generational ZGC (Java 21+): Uses separate generational structure:
Uses pointers carry metadata ("colors") to indicate state changes like relocation.
ZGC uses unused bits in a 64-bit reference to store metadata flags.
The pointer is split into:
 1. 42 bits for the actual memory address
 2. 4 metadata bits (e.g., Marked0, Marked1, Remapped, Finalizable) used by the GC to track object state.
 3. The remaining 18 bits reserved for future use or hardware support 
Only one of these flags is active at a time, indicating the object's state during a GC cycle

A lightweight barrier intercepts pointer use and, if needed, redirects to the new location—all concurrently,
without pausing application threads 

Young Generation: Concurrent, ultra-low pause reclamation of short-lived objects
Old Generation: Concurrent, compacting collection of long-lived objects, all using colored pointer barriers.
When to use: Best for applications with very large heaps and stringent low-latency requirements.
---------------------------------------------------------------------------------------------------------------------------------------
What is a memory leak? where memory leak might occur? Best practices to avoid memory leaks..

A memory leak occurs when a program unintentionally retains references to objects that are no longer needed, 
preventing the JVM’s garbage collector from reclaiming that memory. Despite Java's automatic memory management, 
leaks can still happen when objects remain accessible via strong references

1. Static Collections & Fields
Problem: Data stored in static fields lives for the entire application lifetime, preventing GC cleanup.
Solution: Avoid static mutable collections; if used (like caches), 
clear them or store entries as weak references (WeakHashMap) so unused data can be collected.

2. ThreadLocal Misuse
Problem: ThreadLocal values on pooled threads persist across tasks unless explicitly removed, causing large memory footprints.
Solution: Always call threadLocal.remove() in a finally block after use (especially in thread pools).

3. Unremoved Event Listeners & Callbacks
Problem: Listeners that are registered (e.g., UI callbacks) but not unregistered hold references to objects, preventing their GC.
Solution: Deregister listeners when no longer needed or use weak references for listener registration.

4. Non-Static Inner/Anonymous Classes
Problem: Inner classes implicitly retain a reference to their enclosing instance, 
which can prevent GC when the inner class outlives the outer.
Solution: Use static nested classes or stand-alone classes to avoid unintended references.

5. Unbounded Collections & Improper equals()/hashCode()
Problem: Collections that grow without bounds (like ArrayList, HashMap) never clean up stale entries; 
in hash collections, bad equals/hashCode can lead to hidden memory retention.
Solution: Set size limits, clear unused entries, or use eviction strategies; 
ensure custom keys correctly implement equals() and hashCode().

Note: Regularly profile your app using tools like VisualVM, Eclipse MAT, 
or Java Flight Recorder to detect leaks early and step through heap dumps.

--------------------------------------------------------------------------------------------------------------------------------------------------------
Execution Engine Components
1. Interpreter
Reads bytecode one instruction at a time and executes it directly.
Fast startup, but slow for frequently executed code because each instruction is processed anew every time it's encountered 
HotSpot uses a template-based interpreter: instead of pure software dispatch, each opcode is tied to a native-machine stub for speed 

2. Just-In-Time (JIT) Compiler
Monitors executed methods with a profiler.
Profiling:runtime analysis technique that collects data about the application's behavior, 
such as method invocation frequencies, execution times, and memory usage
Once a method becomes “hot” (exceeds thresholds), it compiles the method’s bytecode into optimized native machine code.
This native code is cached and invoked directly, bypassing the interpreter for subsequent calls 
JIT typically involves:
 Intermediate code generation:
 Optimizations (inlining, escape analysis, dead code elimination)
 Target code generation (producing executable machine code) 

What Is JNI?
The Java Native Interface (JNI) is a framework that allows Java code running in a Java Virtual Machine (JVM) 
to interact with applications and libraries written in other languages. 
It enables Java programs to call native methods, which are implemented in languages like C or C++, and vice versa

public class NativeExample {
    public native void sayHello();
    static {
        System.loadLibrary("nativeLib");
    }
}

Native Method Libraries: These are shared libraries (e.g., .dll on Windows, .so on Linux) 
that contain the implementations of the native methods.

JNI Functions: The JVM provides a set of functions (e.g., GetStringUTFChars, CallVoidMethod) to 
interact with Java objects and invoke Java methods from native code