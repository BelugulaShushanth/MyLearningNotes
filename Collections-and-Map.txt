Iterable -> Collections
-> List -> ArrayList, LinkedList, Vector -> Stack
-> Set -> HashSet -> LinkedHashSet, SortedSet -> TreeSet
-> Queue -> PriorityQueue, Deque -> ArrayDeque

=>List
List in Java provides the facility to maintain the ordered collection. 
It contains the index-based methods to insert, update, delete and search the elements. 
It can have the duplicate elements also. We can also store the null elements in the list.
The List interface is found in the java.util package and inherits the Collection interface

->ArrayList
Java ArrayList class uses a dynamic array for storing the elements. 
It is like an array, but there is no size limit. We can add or remove elements anytime. 
So, it is much more flexible than the traditional array. It is found in the java.util package.
Syntax: ArrayList<Integer> al = new ArrayList<Integer>();
It implements List interface.
1.Java ArrayList class can contain duplicate elements.
2.Java ArrayList class maintains insertion order.
3.Java ArrayList class is non synchronized.
4.Java ArrayList allows random access because the array works on an index basis.
5.In ArrayList, manipulation is a little bit slower than the LinkedList in Java 
because a lot of shifting needs to occur if any element is removed from the array list.
6.We can not create an array list of the primitive types, such as int, float, char, etc. 
It is required to use the required wrapper class in such cases.

->LinkedList
Java LinkedList class uses a doubly linked list to store the elements. 
It provides a linked-list data structure. It inherits the AbstractList class and implements List and Deque interfaces.
Syntax: LinkedList<String> ll=new LinkedList<String>();  
1.Java LinkedList class can contain duplicate elements.
2.Java LinkedList class maintains insertion order.
3.Java LinkedList class is non synchronized.
4.In Java LinkedList class, manipulation is fast because no shifting needs to occur.
5.Java LinkedList class can be used as a list, stack or queue.

=>Set
->HashSet
Java HashSet class is used to create a collection that uses a hash table for storage. 
It inherits the AbstractSet class and implements Set interface.
Syntax: HashSet<String> set=new HashSet();  
1.HashSet stores the elements by using a mechanism called hashing.
2.HashSet contains unique elements only.
3.HashSet allows only one null value.
4.HashSet class is non synchronized.
5.HashSet doesn't maintain the insertion order. Here, elements are inserted on the basis of their hashcode.
6.HashSet is the best approach for search operations.
7.The initial default capacity of HashSet is 16, and the load factor is 0.75.

->LinkedHashSet
Java LinkedHashSet class is a Hashtable and Linked list implementation of the Set interface. 
It inherits the HashSet class and implements the Set interface.
1.Java LinkedHashSet class contains unique elements only like HashSet.
2.Java LinkedHashSet class provides all optional set operations and permits null elements.
3.Java LinkedHashSet class is non-synchronized.
4.Java LinkedHashSet class maintains insertion order.

->TreeSet
Java TreeSet class implements the Set interface that uses a tree for storage. 
It inherits AbstractSet class and implements the NavigableSet interface. 
The objects of the TreeSet class are stored in ascending order.
1.Java TreeSet class contains unique elements only like HashSet.
2.Java TreeSet class access and retrieval times are quite fast.
3.Java TreeSet class doesn't allow null elements.
4.Java TreeSet class is non-synchronized.
5.Java TreeSet class maintains ascending order.

=>Map
->HasMap -> LinkedHashMap
->SortedMap -> TreeMap

A map contains values on the basis of key, i.e. key and value pair. 
Each key and value pair is known as an entry. A Map contains unique keys.
A Map is useful if you have to search, update or delete elements on the basis of a key.
A Map doesn't allow duplicate keys, but you can have duplicate values. 
HashMap and LinkedHashMap allow null keys and values, but TreeMap doesn't allow any null key or value.

HashMap: HashMap is the implementation of Map, but it doesn't maintain any order.
LinkedHashMap: LinkedHashMap is the implementation of Map. It inherits HashMap class. It maintains insertion order.
TreeMap: TreeMap is the implementation of Map and SortedMap. It maintains ascending order.

->HashMap
Java HashMap class implements the Map interface which allows us to store key and value pair, 
where keys should be unique. If you try to insert the duplicate key, it will replace the element 
of the corresponding key. It is easy to perform operations using the key index like updation, deletion, etc. 
HashMap class is found in the java.util package.
HashMap in Java is like the legacy Hashtable class, but it is not synchronized.
Syntax: HashMap<Integer,String> map=new HashMap<Integer,String>();
1.Java HashMap contains values based on the key.
2.Java HashMap contains only unique keys.
3.Java HashMap may have one null key and multiple null values.
4.Java HashMap is non synchronized.
5.Java HashMap maintains no order.
6.The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

=>Working of HashMap in Java - Important
What is Hashing
It is the process of converting an object into an integer value. 
The integer value helps in indexing and faster searches.

What is HashMap
HashMap is a part of the Java collection framework. 
It uses a technique called Hashing. It implements the map interface. 
It stores the data in the pair of Key and Value. 
HashMap contains an array of the nodes, and the node is represented as a class. 
It uses an array and LinkedList data structure internally for storing Key and Value

equals(): It checks the equality of two objects. It compares the Key, whether they are equal or not. 
It is a method of the Object class. It can be overridden. 
If you override the equals() method, then it is mandatory to override the hashCode() method.

hashCode(): This is the method of the object class. 
It returns the memory reference of the object in integer form. 
The value received from the method is used as the bucket number. 
The bucket number is the address of the element inside the map. Hash code of null Key is 0.

Buckets: Array of the node is called buckets. 
Each node has a data structure like a LinkedList. More than one node can share the same bucket. 
It may be different in capacity.

Read More here: https://www.javatpoint.com/working-of-hashmap-in-java

->LinkedHashMap 
Java LinkedHashMap class is Hashtable and Linked list implementation of the Map interface, 
with predictable iteration order. It inherits HashMap class and implements the Map interface
1.Java LinkedHashMap contains values based on the key.
2.Java LinkedHashMap contains unique elements.
3.Java LinkedHashMap may have one null key and multiple null values.
4.Java LinkedHashMap is non synchronized.
5.Java LinkedHashMap maintains insertion order.
6.The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

->TreeMap
1.Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
2.Java TreeMap contains only unique elements.
3.Java TreeMap cannot have a null key but can have multiple null values.
4.Java TreeMap is non synchronized.
5.Java TreeMap maintains ascending order

->HashTable
A Hashtable is an array of a list. Each list is known as a bucket. 
The position of the bucket is identified by calling the hashcode() method. 
A Hashtable contains values based on the key.
1.Java Hashtable class contains unique elements.
2.Java Hashtable class doesn't allow null key or value.
3.Java Hashtable class is synchronized.
4.The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.

=>Java Comparable interface:
Java Comparable interface is used to order the objects of the user-defined class. 
This interface is found in java.lang package and contains only one method named compareTo(Object). 
It provides a single sorting sequence only, i.e., you can sort the elements on the basis of single data member only. 
For example, it may be rollno, name, age or anything else.

compareTo(Object obj) method
public int compareTo(Object obj): It is used to compare the current object with the specified object. It returns
positive integer, if the current object is greater than the specified object.
negative integer, if the current object is less than the specified object.
zero, if the current object is equal to the specified object.

Collections class
Collections class provides static methods for sorting the elements of collections. 
If collection elements are of Set or Map, we can use TreeSet or TreeMap. 
However, we cannot sort the elements of List. 
Collections class provides methods for sorting the elements of List type elements.

Method of Collections class for sorting List elements
public void sort(List list): It is used to sort the elements of List. List elements must be of the Comparable type.

Java Comparable Example
class Student implements Comparable<Student>{  
int rollno;  
String name;  
int age;  
Student(int rollno,String name,int age){  
this.rollno=rollno;  
this.name=name;  
this.age=age;  
}  
  
public int compareTo(Student st){  
if(age==st.age)  
return 0;  
else if(age>st.age)  
return 1;  
else  
return -1;  
}  
}  

in main method: Collections.sort(al);  -> prints students in ascending order of age
To print descending order use below code:
public int compareTo(Student st){    
 if(age==st.age)    
 return 0;    
 else if(age<st.age)    
 return 1;    
 else    
 return -1;    
 }    
 
=>Java Comparator interface
Java Comparator interface is used to order the objects of a user-defined class.
This interface is found in java.util package
It contains 2 methods compare(Object obj1,Object obj2) and equals(Object element).
It provides multiple sorting sequences, i.e., you can sort the elements on the basis of any data member, 
for example, rollno, name, age or anything else.

Method of Collections class for sorting List elements
public void sort(List list, Comparator c): is used to sort the elements of List by the given Comparator.
Example:
class AgeComparator implements Comparator{  
public int compare(Object o1,Object o2){  
Student s1=(Student)o1;  
Student s2=(Student)o2;  
  
if(s1.age==s2.age)  
return 0;  
else if(s1.age>s2.age)  
return 1;  
else  
return -1;  
}  
}  